From ed088b113d630765987cff3b9b26c3530045b0cc Mon Sep 17 00:00:00 2001
From: donglianghao <donglianghao@espressif.com>
Date: Thu, 20 Aug 2020 16:33:12 +0800
Subject: [PATCH] adf_ota_patch

---
 components/ota_service/include/ota_service.h |   8 +-
 components/ota_service/ota_proc_default.c    |   2 +-
 components/ota_service/ota_service.c         |  59 +-
 examples/korvo_du1906/main/app_control.c     |   3 +-
 examples/korvo_du1906/main/app_ota_upgrade.c | 669 +++++++++++++++----
 examples/korvo_du1906/main/app_ota_upgrade.h |   2 +
 examples/korvo_du1906/main/ota_proc_iot.c    | 307 +++++++++
 examples/korvo_du1906/main/ota_proc_iot.h    |  77 +++
 8 files changed, 957 insertions(+), 170 deletions(-)
 create mode 100644 examples/korvo_du1906/main/ota_proc_iot.c
 create mode 100644 examples/korvo_du1906/main/ota_proc_iot.h

diff --git a/components/ota_service/include/ota_service.h b/components/ota_service/include/ota_service.h
index 21d8e727..9f7ad68e 100644
--- a/components/ota_service/include/ota_service.h
+++ b/components/ota_service/include/ota_service.h
@@ -56,11 +56,17 @@ typedef struct {
     char *label;
     char *uri;
     char *cert_pem;
+
+    char *current_version;
+    size_t cus_offset;
+    size_t cus_bin_len;
+    char *cus_checksum;
 } ota_node_attr_t;
 
 typedef enum {
     OTA_SERV_EVENT_TYPE_RESULT,
-    OTA_SERV_EVENT_TYPE_FINISH
+    OTA_SERV_EVENT_TYPE_OK_FINISH,
+    OTA_SERV_EVENT_TYPE_FAIL_FINISH
 } ota_service_event_type_t;
 
 typedef enum {
diff --git a/components/ota_service/ota_proc_default.c b/components/ota_service/ota_proc_default.c
index 796d339d..6770f28a 100644
--- a/components/ota_service/ota_proc_default.c
+++ b/components/ota_service/ota_proc_default.c
@@ -114,7 +114,7 @@ static ota_service_err_reason_t ota_app_partition_prepare(void **handle, ota_nod
         esp_https_ota_config_t ota_config = {
             .http_config = &config,
         };
-        esp_err_t err = esp_https_ota_begin(&ota_config, &context->ota_handle);
+        esp_err_t err = esp_https_ota_begin_with_pos(&ota_config, &context->ota_handle, 0);
         if (err != ESP_OK) {
             ESP_LOGE(TAG, "ESP HTTPS OTA Begin failed");
             return OTA_SERV_ERR_REASON_UNKNOWN;
diff --git a/components/ota_service/ota_service.c b/components/ota_service/ota_service.c
index 907f6201..e029c3f8 100644
--- a/components/ota_service/ota_service.c
+++ b/components/ota_service/ota_service.c
@@ -80,34 +80,47 @@ static void ota_service_cmd_send(void *que, int cmd, void *data, int dir)
     }
 }
 
-static ota_service_err_reason_t ota_service_process(ota_upgrade_ops_t *upgrade_info)
+static esp_err_t ota_service_process(ota_upgrade_ops_t *upgrade_info)
 {
-    ota_service_err_reason_t ret = OTA_SERV_ERR_REASON_UNKNOWN;
+    esp_err_t ret = ESP_FAIL;
+    bool need_upgrade;
     void *handle = NULL;
 
-    AUDIO_NULL_CHECK(TAG, upgrade_info, return OTA_SERV_ERR_REASON_NULL_POINTER);
-    AUDIO_NULL_CHECK(TAG, upgrade_info->prepare, return OTA_SERV_ERR_REASON_NULL_POINTER);
-    AUDIO_NULL_CHECK(TAG, upgrade_info->need_upgrade, return OTA_SERV_ERR_REASON_NULL_POINTER);
-    AUDIO_NULL_CHECK(TAG, upgrade_info->execute_upgrade, return OTA_SERV_ERR_REASON_NULL_POINTER);
-
-    ret = upgrade_info->prepare(&handle, &upgrade_info->node);
-    if (ret != OTA_SERV_ERR_REASON_SUCCESS) {
-        ESP_LOGE(TAG, "OTA prepared fail");
-        return ret;
+    if (!upgrade_info) {
+        return ESP_FAIL;
+    }
+    if (upgrade_info->prepare) {
+        ret = upgrade_info->prepare(&handle, &upgrade_info->node);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "ota upgrade prepare failed");
+            return ESP_FAIL;
+        }
+    }
+    if (upgrade_info->need_upgrade) {
+        need_upgrade = upgrade_info->need_upgrade(handle, &upgrade_info->node);
+        if (false == need_upgrade) {
+            ESP_LOGE(TAG, "no need upgrade, skip this partition");
+            //return ESP_FAIL;
+            return ESP_OK;
+        }
     }
-    ret = upgrade_info->need_upgrade(handle, &upgrade_info->node);
-    if (ret != OTA_SERV_ERR_REASON_SUCCESS) {
-        ESP_LOGE(TAG, "No need to upgrade");
-        return ret;
+    if (upgrade_info->execute_upgrade) {
+        ret = upgrade_info->execute_upgrade(handle, &upgrade_info->node);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "ota upgrade execute_upgrade failed");
+            return ESP_FAIL;
+        }
     }
-    ret = upgrade_info->execute_upgrade(handle, &upgrade_info->node);
-    if (ret != OTA_SERV_ERR_REASON_SUCCESS) {
-        ESP_LOGE(TAG, "Fail to execute upgrade");
-        return ret;
+    if (upgrade_info->finished_check) {
+        ret = upgrade_info->finished_check(handle, &upgrade_info->node, ret);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "ota upgrade finished_check failed");
+            return ESP_FAIL;
+        }
     }
 
-    AUDIO_CHECK(TAG, upgrade_info->finished_check != NULL, return OTA_SERV_ERR_REASON_NULL_POINTER, "finished_check should not be NULL");
-    return upgrade_info->finished_check(handle, &upgrade_info->node, ret);
+    return  ESP_OK;
+
 }
 
 static void ota_task(void *pvParameters)
@@ -117,6 +130,7 @@ static void ota_task(void *pvParameters)
     ota_msg_t msg = { 0 };
     periph_service_event_t ser_evt = { 0 };
     ota_result_t result_data = { 0 };
+    ota_service_event_type_t final_result = OTA_SERV_EVENT_TYPE_OK_FINISH;
 
     ota->state = OTA_IDLE;
     while (true) {
@@ -161,6 +175,7 @@ static void ota_task(void *pvParameters)
                     periph_service_callback(serv_handle, &ser_evt);
                     if (ret != OTA_SERV_ERR_REASON_SUCCESS && cur_node->break_after_fail) {
                         ESP_LOGE(TAG, "upgrade_list[%d] OTA failed, break the update list", i);
+                        final_result = OTA_SERV_EVENT_TYPE_FAIL_FINISH;
                         break;
                     }
                 }
@@ -178,7 +193,7 @@ static void ota_task(void *pvParameters)
                     }
                 }
                 memset(&ser_evt, 0, sizeof(periph_service_event_t));
-                ser_evt.type = OTA_SERV_EVENT_TYPE_FINISH;
+                ser_evt.type = final_result;
                 periph_service_callback(serv_handle, &ser_evt);
 
                 ota->state = OTA_IDLE;
diff --git a/examples/korvo_du1906/main/app_control.c b/examples/korvo_du1906/main/app_control.c
index c0e20815..0f05ddbe 100755
--- a/examples/korvo_du1906/main/app_control.c
+++ b/examples/korvo_du1906/main/app_control.c
@@ -169,6 +169,7 @@ static esp_err_t input_key_service_cb(periph_service_handle_t handle, periph_ser
                 ESP_LOGI(TAG, "Now volume is %d", player_volume);
             } else if (evt->type == INPUT_KEY_SERVICE_ACTION_PRESS) {
                 ESP_LOGI(TAG, "[ * ] [Vol+] press event");
+                bdsc_ota_start(NULL, 0);
             }
         default:
             break;
@@ -266,7 +267,7 @@ void app_init(void)
     // step 5. wait for wifi connected, and start ota service
     EventBits_t bits = xEventGroupWaitBits(WIFI_CONNECTED_FLAG, WIFI_CONNECTED_BIT, true, false, WIFI_WAIT_CONNECT_TIME_MS);
     if (bits & WIFI_CONNECTED_BIT) {
-        app_ota_start();
+        //bdsc_ota_start(NULL, 0);
     } else {
         ESP_LOGW(TAG, "WIFI  connection timeout(%dms), skipped OTA service", WIFI_WAIT_CONNECT_TIME_MS);
     }
diff --git a/examples/korvo_du1906/main/app_ota_upgrade.c b/examples/korvo_du1906/main/app_ota_upgrade.c
index 90e3da34..e85628ad 100644
--- a/examples/korvo_du1906/main/app_ota_upgrade.c
+++ b/examples/korvo_du1906/main/app_ota_upgrade.c
@@ -29,11 +29,17 @@
 #include "freertos/event_groups.h"
 #include "esp_log.h"
 #include "audio_error.h"
-#include "audio_mem.h"
 #include "esp_partition.h"
 #include "ota_service.h"
 #include "ota_proc_default.h"
 #include "tone_partition.h"
+#include "ota_proc_iot.h"
+#include "bdsc_event_dispatcher.h"
+#include "bdsc_json.h"
+#include "bdsc_engine.h"
+#include "audio_player.h"
+#include "display_service.h"
+#include "audio_mem.h"
 
 static const char *TAG = "APP_OTA_UPGRADE";
 
@@ -41,111 +47,151 @@ static EventGroupHandle_t OTA_FLAG;
 #define OTA_FINISH (BIT0)
 #define OTA_SERVICE_STACK_SIZE  (4 * 1024)
 
-static ota_service_err_reason_t ota_sdcard_image_need_upgrade(void *handle, ota_node_attr_t *node)
+#define DUL1906_OTA_BIN_DEF_URL             "https://jinzhong.bj.bcebos.com/dul1906_new_ota.bin"
+#define DUL1906_NEED_OTA_PARTITION_NUM      3
+
+enum {
+    DUL1906_OTA_PARTITION_ID_FLASH_TONE = 0,
+    DUL1906_OTA_PARTITION_ID_DSP_BIN    = 1,
+    DUL1906_OTA_PARTITION_ID_APP        = 2,
+};
+
+extern display_service_handle_t disp_serv;
+
+typedef struct _bdsc_ota_info_t {
+    char *url;
+    int ver;
+} bdsc_ota_info_t;
+
+
+typedef struct {
+    int version;
+
+    char   *tone_sub_version;
+    size_t tone_offset;
+    size_t tone_len;
+    char   *tone_checksum;
+
+    char   *dsp_sub_version;
+    size_t dsp_offset;
+    size_t dsp_len;
+    char   *dsp_checksum;
+
+    char   *app_sub_version;
+    size_t app_offset;
+    size_t app_len;
+    char   *app_checksum;
+
+} custom_ota_bin_desc_t;
+
+custom_ota_bin_desc_t *g_custom_ota_bin_desc = NULL;
+
+static int save_tone_subver_to_profile(char *sub_ver)
 {
-    AUDIO_NULL_CHECK(TAG, handle, return OTA_SERV_ERR_REASON_NULL_POINTER);
-    AUDIO_NULL_CHECK(TAG, node->uri, return OTA_SERV_ERR_REASON_NULL_POINTER);
-    const esp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, node->label);
-    if (partition == NULL) {
-        ESP_LOGE(TAG, "data partition [%s] not found", node->label);
-        return OTA_SERV_ERR_REASON_PARTITION_NOT_FOUND;
-    }
+    int err;
+    vendor_info_t *g_vendor_info = g_bdsc_engine->g_vendor_info;
 
-    char *uri = strstr(node->uri, "/sdcard/");
-    if (access(uri, 0) == 0) {
-        ESP_LOGI(TAG, "Found ota file in sdcard, uri: %s", uri);
-        esp_err_t err = ESP_OK;
-        if ((err = esp_partition_erase_range(partition, 0, partition->size)) != ESP_OK) {
-            ESP_LOGE(TAG, "Erase [%s] failed and return %d", node->label, err);
-            return OTA_SERV_ERR_REASON_PARTITION_WT_FAIL;
+    if (g_vendor_info->tone_sub_ver) {
+        free(g_vendor_info->tone_sub_ver);
+        g_vendor_info->tone_sub_ver = audio_strdup(sub_ver);
+        if (g_bdsc_engine->profile_json) {
+            cJSON_DeleteItemFromObject(g_bdsc_engine->profile_json, "tone_sub_ver");
+            cJSON_AddStringToObject(g_bdsc_engine->profile_json, "tone_sub_ver", sub_ver);
         }
-        return OTA_SERV_ERR_REASON_SUCCESS;
-    } else {
-        return OTA_SERV_ERR_REASON_FILE_NOT_FOUND;
     }
+    err = profile_save();
+    if (ESP_OK != err) {
+        ESP_LOGE(TAG, "profile save fail, err: %d", err);
+        return ESP_FAIL;
+    }
+    ESP_LOGI(TAG, "profile save OK");
+    return ESP_OK;
 }
 
-static ota_service_err_reason_t ota_http_tone_image_need_upgrade(void *handle, ota_node_attr_t *node)
+static int save_dsp_subver_to_profile(char *sub_ver)
 {
-    bool                need_write_desc = false;
-    flash_tone_header_t cur_header      = { 0 };
-    flash_tone_header_t incoming_header = { 0 };
-    esp_app_desc_t      current_desc    = { 0 };
-    esp_app_desc_t      incoming_desc   = { 0 };
-    esp_err_t           err             = ESP_OK;
+    int err;
+    vendor_info_t *g_vendor_info = g_bdsc_engine->g_vendor_info;
 
-    /* try to get the tone partition*/
-    const esp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, node->label);
-    if (partition == NULL) {
-        ESP_LOGE(TAG, "data partition [%s] not found", node->label);
-        return OTA_SERV_ERR_REASON_PARTITION_NOT_FOUND;
+    if (g_vendor_info->dsp_sub_ver) {
+        free(g_vendor_info->dsp_sub_ver);
+        g_vendor_info->dsp_sub_ver = audio_strdup(sub_ver);
+        if (g_bdsc_engine->profile_json) {
+            cJSON_DeleteItemFromObject(g_bdsc_engine->profile_json, "dsp_sub_ver");
+            cJSON_AddStringToObject(g_bdsc_engine->profile_json, "dsp_sub_ver", sub_ver);
+        }
     }
-    tone_partition_handle_t tone = tone_partition_init(node->label, false);
-    if (tone == NULL) {
-        esp_partition_erase_range(partition, 0, partition->size);
-        return OTA_SERV_ERR_REASON_SUCCESS;
+    err = profile_save();
+    if (ESP_OK != err) {
+        ESP_LOGE(TAG, "profile save fail, err: %d", err);
+        return ESP_FAIL;
     }
+    ESP_LOGI(TAG, "profile save OK");
+    return ESP_OK;
+}
 
-    /* Read tone header from partition */
-    if (esp_partition_read(partition, 0, (char *)&cur_header, sizeof(flash_tone_header_t)) != ESP_OK) {
-        return OTA_SERV_ERR_REASON_PARTITION_RD_FAIL;
-    }
+static int save_app_subver_to_profile(char *sub_ver, int current_version_num)
+{
+    int err;
+    vendor_info_t *g_vendor_info = g_bdsc_engine->g_vendor_info;
 
-    /* Read tone header from incoming stream */
-    if (ota_data_image_stream_read(handle, (char *)&incoming_header, sizeof(flash_tone_header_t)) != ESP_OK) {
-        return OTA_SERV_ERR_REASON_STREAM_RD_FAIL;
-    }
-    if (incoming_header.header_tag != 0x2053) {
-        ESP_LOGE(TAG, "not audio tone bin");
-        return OTA_SERV_ERR_REASON_UNKNOWN;
-    }
-    ESP_LOGI(TAG, "format %d : %d", cur_header.format, incoming_header.format);
-    /* upgrade the tone bin when incoming bin format is 0 */
-    if (incoming_header.format == 0) {
-        goto write_flash;
-    }
+    if (g_vendor_info->app_sub_ver) {
+        free(g_vendor_info->app_sub_ver);
+        g_vendor_info->app_sub_ver = audio_strdup(sub_ver);
+        if (g_bdsc_engine->profile_json) {
+            cJSON_DeleteItemFromObject(g_bdsc_engine->profile_json, "app_sub_ver");
+            cJSON_AddStringToObject(g_bdsc_engine->profile_json, "app_sub_ver", sub_ver);
 
-    /* read the app desc from incoming stream when bin format is 1*/
-    if (ota_data_image_stream_read(handle, (char *)&incoming_desc, sizeof(esp_app_desc_t)) != ESP_OK) {
-        return OTA_SERV_ERR_REASON_STREAM_RD_FAIL;
-    }
-    ESP_LOGI(TAG, "imcoming magic_word %X, project_name %s", incoming_desc.magic_word, incoming_desc.project_name);
-    /* check the incoming app desc */
-    if (incoming_desc.magic_word != FLASH_TONE_MAGIC_WORD) {
-        return OTA_SERV_ERR_REASON_ERROR_MAGIC_WORD;
+            cJSON_DeleteItemFromObject(g_bdsc_engine->profile_json, "cur_version_num");
+            cJSON_AddNumberToObject(g_bdsc_engine->profile_json, "cur_version_num", current_version_num);
+        }
     }
-    if (strstr(FLASH_TONE_PROJECT_NAME, incoming_desc.project_name) == NULL) {
-        return OTA_SERV_ERR_REASON_ERROR_PROJECT_NAME;
+    err = profile_save();
+    if (ESP_OK != err) {
+        ESP_LOGE(TAG, "profile save fail, err: %d", err);
+        return ESP_FAIL;
     }
+    ESP_LOGI(TAG, "profile save OK");
+    return ESP_OK;
+}
 
-    /* compare current app desc with the incoming one if the current bin's format is 1*/
-    if (cur_header.format == TONE_VERSION_1) {
-        if (tone_partition_get_app_desc(tone, &current_desc) != ESP_OK) {
-            return OTA_SERV_ERR_REASON_PARTITION_RD_FAIL;
+static void custom_ota_bin_desc_cleanup()
+{
+    if (g_custom_ota_bin_desc) {
+        if (g_custom_ota_bin_desc->tone_sub_version) {
+            free(g_custom_ota_bin_desc->tone_sub_version);
+        }
+        if (g_custom_ota_bin_desc->tone_checksum) {
+            free(g_custom_ota_bin_desc->tone_checksum);
         }
-        if (ota_get_version_number(incoming_desc.version) < 0) {
-            return OTA_SERV_ERR_REASON_ERROR_VERSION;
+        if (g_custom_ota_bin_desc->dsp_sub_version) {
+            free(g_custom_ota_bin_desc->dsp_sub_version);
         }
-        ESP_LOGI(TAG, "current version %s, incoming version %s", current_desc.version, incoming_desc.version);
-        if (ota_get_version_number(incoming_desc.version) <= ota_get_version_number(current_desc.version)) {
-            ESP_LOGW(TAG, "The incoming version is same as or lower than the running version");
-            return OTA_SERV_ERR_REASON_NO_HIGHER_VERSION;
+        if (g_custom_ota_bin_desc->dsp_checksum) {
+            free(g_custom_ota_bin_desc->dsp_checksum);
         }
+        if (g_custom_ota_bin_desc->app_sub_version) {
+            free(g_custom_ota_bin_desc->app_sub_version);
+        }
+        if (g_custom_ota_bin_desc->app_checksum) {
+            free(g_custom_ota_bin_desc->app_checksum);
+        }
+        free(g_custom_ota_bin_desc);
+        g_custom_ota_bin_desc = NULL;
     }
+}
 
-    /* incoming bin's format is 1, and the current bin's format is 0, upgrade the incoming one */
-    need_write_desc = true;
-
-write_flash:
-    if ((err = esp_partition_erase_range(partition, 0, partition->size)) != ESP_OK) {
-        ESP_LOGE(TAG, "Erase [%s] failed and return %d", node->label, err);
-        return OTA_SERV_ERR_REASON_PARTITION_WT_FAIL;
-    }
-    ota_data_partition_write(handle, (char *)&incoming_header, sizeof(flash_tone_header_t));
-    if (need_write_desc) {
-        ota_data_partition_write(handle, (char *)&incoming_desc, sizeof(esp_app_desc_t));
+static int _return_ota_error(int errcode)
+{
+    if (errcode == 0) {
+        bdsc_play_hint(BDSC_HINT_OTA_COMPLETE);
+    } else if (errcode == -1) {
+        bdsc_play_hint(BDSC_HINT_OTA_FAIL);
+    } else if (errcode == -2) {
+        bdsc_play_hint(BDSC_HINT_OTA_ALREADY_NEWEST);
     }
-    return OTA_SERV_ERR_REASON_SUCCESS;
+
+    return 0;
 }
 
 static esp_err_t ota_service_cb(periph_service_handle_t handle, periph_service_event_t *evt, void *ctx)
@@ -153,18 +199,345 @@ static esp_err_t ota_service_cb(periph_service_handle_t handle, periph_service_e
     if (evt->type == OTA_SERV_EVENT_TYPE_RESULT) {
         ota_result_t *result_data = evt->data;
         if (result_data->result != ESP_OK) {
-            ESP_LOGE(TAG, "List id: %d, OTA failed, result: %d", result_data->id, result_data->result);
+            ESP_LOGE(TAG, "List id: %d, OTA failed", result_data->id);
+            switch (result_data->id) {
+            case DUL1906_OTA_PARTITION_ID_FLASH_TONE:
+            case DUL1906_OTA_PARTITION_ID_DSP_BIN:
+            case DUL1906_OTA_PARTITION_ID_APP:
+                _return_ota_error(-1);
+                break;
+            default:
+                ESP_LOGE(TAG, "invalid partiton type!");
+            }
         } else {
             ESP_LOGI(TAG, "List id: %d, OTA sucessed", result_data->id);
+            switch (result_data->id) {
+            case DUL1906_OTA_PARTITION_ID_FLASH_TONE:
+                if (g_custom_ota_bin_desc->tone_sub_version) {
+                    ESP_LOGE(TAG, "save tone sub_ver: %s", g_custom_ota_bin_desc->tone_sub_version);
+                    save_tone_subver_to_profile(g_custom_ota_bin_desc->tone_sub_version);
+                }
+                break;
+            case DUL1906_OTA_PARTITION_ID_DSP_BIN:
+                if (g_custom_ota_bin_desc->dsp_sub_version) {
+                    ESP_LOGE(TAG, "save dsp sub_ver: %s", g_custom_ota_bin_desc->dsp_sub_version);
+                    save_dsp_subver_to_profile(g_custom_ota_bin_desc->dsp_sub_version);
+                }
+                break;
+            case DUL1906_OTA_PARTITION_ID_APP:
+                if (g_custom_ota_bin_desc->app_sub_version) {
+                    ESP_LOGE(TAG, "save app sub_ver: %s", g_custom_ota_bin_desc->app_sub_version);
+                    save_app_subver_to_profile(g_custom_ota_bin_desc->app_sub_version, g_custom_ota_bin_desc->version);
+                }
+                break;
+            default:
+                ESP_LOGE(TAG, "invalid partiton type!");
+            }
         }
-    } else if (evt->type == OTA_SERV_EVENT_TYPE_FINISH) {
+    } else if (evt->type == OTA_SERV_EVENT_TYPE_OK_FINISH) {
+        _return_ota_error(0);
         xEventGroupSetBits(OTA_FLAG, OTA_FINISH);
+        custom_ota_bin_desc_cleanup();
+        ESP_LOGW(TAG, "restart!");
+        esp_restart();
+    } else if (evt->type == OTA_SERV_EVENT_TYPE_FAIL_FINISH) {
+        xEventGroupSetBits(OTA_FLAG, OTA_FINISH);
+        custom_ota_bin_desc_cleanup();
     }
     return ESP_OK;
 }
 
-void app_ota_start()
+
+static char *get_last_ota_url()
+{
+    char *ret_url = NULL;
+
+    if (g_bdsc_engine->profile_json &&
+        (ret_url = (char *)BdsJsonObjectGetString(g_bdsc_engine->profile_json, "last_ota_url"))) {
+        return ret_url;
+    }
+    return ret_url;
+}
+
+static int set_last_ota_url(char *url)
 {
+    if (!g_bdsc_engine->profile_json ||
+        !url) {
+        return -1;
+    }
+    BdsJsonObjectAddString(g_bdsc_engine->profile_json, "last_ota_url", url);
+    return profile_save();
+}
+
+
+static custom_ota_bin_desc_t *fetch_custom_header_once(char * ota_url)
+{
+    custom_ota_bin_desc_t *bin_desc = NULL;
+    cJSON *desc_j = NULL;
+    char *last_url;
+
+    // if has url, use it
+    if (!ota_url) {
+        // if no url, use last
+        if ((last_url = get_last_ota_url())) {
+            ota_url = last_url;
+        } else {
+            // if no last, use default
+            ota_url = DUL1906_OTA_BIN_DEF_URL;
+        }
+    } else {
+        set_last_ota_url(ota_url);
+    }
+    esp_http_client_config_t config = {
+        .url = ota_url,
+        .cert_pem = NULL,
+        .timeout_ms = 1000,
+    };
+    esp_http_client_handle_t http_client = esp_http_client_init(&config);
+    if (!http_client) {
+        ESP_LOGE(TAG, "Failed to initialise HTTP connection");
+        return NULL;
+    }
+    int err;
+    err = esp_http_client_open(http_client, 0);
+    if (err != ESP_OK) {
+        esp_http_client_cleanup(http_client);
+        ESP_LOGE(TAG, "Failed to open HTTP connection: %s", esp_err_to_name(err));
+        return NULL;
+    }
+    esp_http_client_fetch_headers(http_client);
+    int status_code = esp_http_client_get_status_code(http_client);
+    ESP_LOGI(TAG, "status_code: %d", status_code);
+
+    uint8_t *tmp_buf = NULL;
+    size_t tmp_buf_len = 1024;
+    size_t read_len;
+    if (!(tmp_buf = audio_calloc(1, tmp_buf_len))) {
+        ESP_LOGE(TAG, "malloc error");
+        goto err_out;
+    }
+    read_len = esp_http_client_read(http_client, (char *)tmp_buf, tmp_buf_len);
+    if (read_len != tmp_buf_len) {
+        ESP_LOGE(TAG, "esp_http_client_read error");
+        goto err_out;
+    }
+    char *parse_end;
+    int is_null_terminated;
+    desc_j = cJSON_ParseWithOpts((const char *)tmp_buf, (const char **)&parse_end, (cJSON_bool)&is_null_terminated);
+    if (!desc_j) {
+        ESP_LOGE(TAG, "cJSON_ParseWithOpts error");
+        goto err_out;
+    }
+    bin_desc = (custom_ota_bin_desc_t*)audio_calloc(1, sizeof(custom_ota_bin_desc_t));
+    if (!bin_desc) {
+        ESP_LOGE(TAG, "malloc error");
+        goto err_out;
+    }
+    cJSON *sub_verJ, *offsetJ, *lengthJ, *checksumJ;
+    cJSON *version_j = cJSON_GetObjectItem(desc_j, "version");
+    bin_desc->version = version_j->valueint;
+    cJSON *tone_j = cJSON_GetObjectItem(desc_j, "tone");
+    if (tone_j) {
+        sub_verJ  = cJSON_GetObjectItem(tone_j, "sub_ver");
+        offsetJ   = cJSON_GetObjectItem(tone_j, "offset");
+        lengthJ   = cJSON_GetObjectItem(tone_j, "length");
+        checksumJ = cJSON_GetObjectItem(tone_j, "checksum");
+
+        if (sub_verJ && offsetJ && lengthJ && checksumJ) {
+            ESP_LOGE(TAG, "sub_verJ->valuestring: %s", sub_verJ->valuestring);
+            bin_desc->tone_sub_version = audio_strdup(sub_verJ->valuestring);
+            bin_desc->tone_offset = offsetJ->valueint;
+            bin_desc->tone_len = lengthJ->valueint;
+            bin_desc->tone_checksum = audio_strdup(checksumJ->valuestring);
+        } else {
+            ESP_LOGE(TAG, "custom_ota_bin_desc json format error");
+        }
+    }
+    cJSON *dsp_j = cJSON_GetObjectItem(desc_j, "dsp");
+    if (dsp_j) {
+        sub_verJ  = cJSON_GetObjectItem(dsp_j, "sub_ver");
+        offsetJ   = cJSON_GetObjectItem(dsp_j, "offset");
+        lengthJ   = cJSON_GetObjectItem(dsp_j, "length");
+        checksumJ = cJSON_GetObjectItem(dsp_j, "checksum");
+
+        if (sub_verJ && offsetJ && lengthJ && checksumJ) {
+            ESP_LOGE(TAG, "sub_verJ->valuestring: %s", sub_verJ->valuestring);
+            bin_desc->dsp_sub_version = audio_strdup(sub_verJ->valuestring);
+            bin_desc->dsp_offset = offsetJ->valueint;
+            bin_desc->dsp_len = lengthJ->valueint;
+            bin_desc->dsp_checksum = audio_strdup(checksumJ->valuestring);
+        } else {
+            ESP_LOGE(TAG, "custom_ota_bin_desc json format error");
+        }
+    }
+    cJSON *app_j = cJSON_GetObjectItem(desc_j, "app");
+    if (app_j) {
+        sub_verJ  = cJSON_GetObjectItem(app_j, "sub_ver");
+        offsetJ   = cJSON_GetObjectItem(app_j, "offset");
+        lengthJ   = cJSON_GetObjectItem(app_j, "length");
+        checksumJ = cJSON_GetObjectItem(app_j, "checksum");
+
+        if (sub_verJ && offsetJ && lengthJ && checksumJ) {
+            ESP_LOGE(TAG, "sub_verJ->valuestring: %s", sub_verJ->valuestring);
+            bin_desc->app_sub_version = audio_strdup(sub_verJ->valuestring);
+            bin_desc->app_offset = offsetJ->valueint;
+            bin_desc->app_len = lengthJ->valueint;
+            bin_desc->app_checksum = audio_strdup(checksumJ->valuestring);
+        } else {
+            ESP_LOGE(TAG, "custom_ota_bin_desc json format error");
+        }
+    }
+
+    ESP_LOGI(TAG, "parse custom_ota_bin_desc json success");
+err_out:
+    if (tmp_buf) {
+        free(tmp_buf);
+    }
+    if (desc_j) {
+        cJSON_Delete(desc_j);
+    }
+    esp_http_client_close(http_client);
+    esp_http_client_cleanup(http_client);
+    return bin_desc;
+}
+
+static int version_cmp(char *version1, char *version2)
+{
+    unsigned major1 = 0, minor1 = 0, bugfix1 = 0;
+    unsigned major2 = 0, minor2 = 0, bugfix2 = 0;
+    sscanf(version1, "%u.%u.%u", &major1, &minor1, &bugfix1);
+    sscanf(version2, "%u.%u.%u", &major2, &minor2, &bugfix2);
+    if (major1 < major2) return -1;
+    if (major1 > major2) return 1;
+    if (minor1 < minor2) return -1;
+    if (minor1 > minor2) return 1;
+    if (bugfix1 < bugfix2) return -1;
+    if (bugfix1 > bugfix2) return 1;
+    return 0;
+}
+
+static ota_service_err_reason_t _need_upgrade(void *handle, ota_node_attr_t *node)
+{
+    if (!g_custom_ota_bin_desc) {
+        return false;
+    }
+
+    // version compare
+    if (g_bdsc_engine->g_vendor_info->cur_version_num >= g_custom_ota_bin_desc->version) {
+        ESP_LOGI(TAG, "version already newest, pass");
+        return false;
+    }
+    // sub_ver compare
+    if (!strcmp(node->label, "flash_tone")) {
+        if (!g_custom_ota_bin_desc->tone_sub_version) {
+            ESP_LOGI(TAG, "no conf in json file, pass");
+            return false;
+        }
+        if (version_cmp(g_custom_ota_bin_desc->tone_sub_version, node->current_version) <= 0) {
+            return false;
+        }
+        node->cus_offset = g_custom_ota_bin_desc->tone_offset;
+        node->cus_bin_len = g_custom_ota_bin_desc->tone_len;
+        node->cus_checksum = g_custom_ota_bin_desc->tone_checksum;
+    } else if (!strcmp(node->label, "dsp_bin")) {
+        if (!g_custom_ota_bin_desc->dsp_sub_version) {
+            // no conf in json file
+            return false;
+        }
+        if (version_cmp(g_custom_ota_bin_desc->dsp_sub_version, node->current_version) <= 0) {
+            return false;
+        }
+        node->cus_offset = g_custom_ota_bin_desc->dsp_offset;
+        node->cus_bin_len = g_custom_ota_bin_desc->dsp_len;
+        node->cus_checksum = g_custom_ota_bin_desc->dsp_checksum;
+    } else if (!strcmp(node->label, "app")) {
+        if (!g_custom_ota_bin_desc->app_sub_version) {
+            // no conf in json file
+            return false;
+        }
+        if (version_cmp(g_custom_ota_bin_desc->app_sub_version, node->current_version) <= 0) {
+            return false;
+        }
+        node->cus_offset = g_custom_ota_bin_desc->app_offset;
+        node->cus_bin_len = g_custom_ota_bin_desc->app_len;
+        node->cus_checksum = g_custom_ota_bin_desc->app_checksum;
+    } else {
+        ESP_LOGI(TAG, "unkonw partiton");
+        return false;
+    }
+
+    return true;
+}
+
+ota_upgrade_ops_t *generate_custom_upgrade_list(char *custom_url)
+{
+    ota_upgrade_ops_t *list = audio_calloc(DUL1906_NEED_OTA_PARTITION_NUM, sizeof(ota_upgrade_ops_t));
+    if (!list) {
+        return NULL;
+    }
+    if (!custom_url) {
+        custom_url = DUL1906_OTA_BIN_DEF_URL;
+    }
+
+    /* flash tone ota config */
+    list[DUL1906_OTA_PARTITION_ID_FLASH_TONE].node.type         = ESP_PARTITION_TYPE_DATA;
+    list[DUL1906_OTA_PARTITION_ID_FLASH_TONE].node.uri          = custom_url;
+    list[DUL1906_OTA_PARTITION_ID_FLASH_TONE].node.label        = "flash_tone";
+    list[DUL1906_OTA_PARTITION_ID_FLASH_TONE].node.cert_pem     = NULL;
+    list[DUL1906_OTA_PARTITION_ID_FLASH_TONE].node.current_version = g_bdsc_engine->g_vendor_info->tone_sub_ver;
+    list[DUL1906_OTA_PARTITION_ID_FLASH_TONE].break_after_fail  = true;
+    list[DUL1906_OTA_PARTITION_ID_FLASH_TONE].reboot_flag       = false;
+    ota_data_get_custom_proc(&list[DUL1906_OTA_PARTITION_ID_FLASH_TONE]);
+    list[DUL1906_OTA_PARTITION_ID_FLASH_TONE].need_upgrade = _need_upgrade;
+
+    /* dsp_bin ota config */
+    list[DUL1906_OTA_PARTITION_ID_DSP_BIN].node.type         = ESP_PARTITION_TYPE_DATA;
+    list[DUL1906_OTA_PARTITION_ID_DSP_BIN].node.uri          = custom_url;
+    list[DUL1906_OTA_PARTITION_ID_DSP_BIN].node.label        = "dsp_bin";
+    list[DUL1906_OTA_PARTITION_ID_DSP_BIN].node.cert_pem     = NULL;
+    list[DUL1906_OTA_PARTITION_ID_DSP_BIN].node.current_version = g_bdsc_engine->g_vendor_info->dsp_sub_ver;
+    list[DUL1906_OTA_PARTITION_ID_DSP_BIN].break_after_fail  = true;
+    list[DUL1906_OTA_PARTITION_ID_DSP_BIN].reboot_flag       = false;
+    ota_data_get_custom_proc(&list[DUL1906_OTA_PARTITION_ID_DSP_BIN]);
+    list[DUL1906_OTA_PARTITION_ID_DSP_BIN].need_upgrade = _need_upgrade;
+
+    /* app ota config */
+    list[DUL1906_OTA_PARTITION_ID_APP].node.type         = ESP_PARTITION_TYPE_APP;
+    list[DUL1906_OTA_PARTITION_ID_APP].node.uri          = custom_url;
+    list[DUL1906_OTA_PARTITION_ID_APP].node.label        = "app";
+    list[DUL1906_OTA_PARTITION_ID_APP].node.cert_pem     = NULL;
+    list[DUL1906_OTA_PARTITION_ID_APP].node.current_version = g_bdsc_engine->g_vendor_info->app_sub_ver;
+    list[DUL1906_OTA_PARTITION_ID_APP].break_after_fail  = true;
+    list[DUL1906_OTA_PARTITION_ID_APP].reboot_flag       = false;
+    ota_app_get_custom_proc(&list[DUL1906_OTA_PARTITION_ID_APP]);
+    list[DUL1906_OTA_PARTITION_ID_APP].need_upgrade = _need_upgrade;
+    return list;
+}
+
+void app_ota_start(char *custom_url)
+{
+    /* fetch custom header once */
+    if (g_custom_ota_bin_desc) {
+        ESP_LOGE(TAG, "already in ota, pass");
+        _return_ota_error(-1);
+        return;
+    }
+    g_custom_ota_bin_desc = fetch_custom_header_once(custom_url);
+    if (!g_custom_ota_bin_desc) {
+        ESP_LOGE(TAG, "fetch_custom_header_once failed");
+        _return_ota_error(-1);
+        return;
+    }
+
+    ESP_LOGI(TAG, "server version: %d, local version: %d", g_custom_ota_bin_desc->version,
+                                                           g_bdsc_engine->g_vendor_info->cur_version_num);
+    if (g_custom_ota_bin_desc->version <= g_bdsc_engine->g_vendor_info->cur_version_num) {
+        ESP_LOGE(TAG, "firmware alreay newest, pass");
+        _return_ota_error(-2);
+        custom_ota_bin_desc_cleanup();
+        return;
+    }
+
     ESP_LOGI(TAG, "Create OTA service");
     OTA_FLAG = xEventGroupCreate();
     ota_service_config_t ota_service_cfg = OTA_SERVICE_DEFAULT_CONFIG();
@@ -172,66 +545,15 @@ void app_ota_start()
     ota_service_cfg.evt_cb = ota_service_cb;
     ota_service_cfg.cb_ctx = NULL;
     periph_service_handle_t ota_service = ota_service_create(&ota_service_cfg);
-    ota_upgrade_ops_t upgrade_list[] = {
-        {
-            {
-                ESP_PARTITION_TYPE_DATA,
-                "flash_tone",
-                "https://github.com/espressif/esp-adf/raw/master/examples/korvo_du1906/tone/audio_tone.bin",
-                NULL
-            },
-            NULL,
-            NULL,
-            NULL,
-            NULL,
-            false,
-            false
-        },
-        {
-            {
-                ESP_PARTITION_TYPE_DATA,
-                "profile",
-                "file://sdcard/profile.bin",
-                NULL
-            },
-            NULL,
-            NULL,
-            NULL,
-            NULL,
-            false,
-            false
-        },
-        {
-            {
-                ESP_PARTITION_TYPE_APP,
-                NULL,
-                "https://github.com/espressif/esp-adf/raw/master/examples/korvo_du1906/firmware/app.bin",
-                NULL
-            },
-            NULL,
-            NULL,
-            NULL,
-            NULL,
-            true,
-            false
-        }
-    };
 
-    for (int i = 0; i < sizeof(upgrade_list) / sizeof(upgrade_list[0]); i++) {
-        if (upgrade_list[i].node.type == ESP_PARTITION_TYPE_DATA) {
-            ota_data_get_default_proc(&upgrade_list[i]);
-            if (strcmp(upgrade_list[i].node.label, "flash_tone") == 0 && strstr(upgrade_list[i].node.uri, "http")) {
-                upgrade_list[i].need_upgrade = ota_http_tone_image_need_upgrade;
-            } else {
-                upgrade_list[i].need_upgrade = ota_sdcard_image_need_upgrade;
-            }
-        } else if (upgrade_list[i].node.type == ESP_PARTITION_TYPE_APP) {
-            ota_app_get_default_proc(&upgrade_list[i]);
-        } else {
-            ESP_LOGE(TAG, "unknown type");
-        }
+    ota_upgrade_ops_t *upgrade_list = generate_custom_upgrade_list(custom_url);
+    if (!upgrade_list) {
+        periph_service_destroy(ota_service);
+        custom_ota_bin_desc_cleanup();
+        return;
     }
-    ota_service_set_upgrade_param(ota_service, upgrade_list, sizeof(upgrade_list) / sizeof(upgrade_list[0]));
+
+    ota_service_set_upgrade_param(ota_service, upgrade_list, DUL1906_NEED_OTA_PARTITION_NUM);
     ESP_LOGI(TAG, "Start OTA service");
     periph_service_start(ota_service);
     EventBits_t bits = xEventGroupWaitBits(OTA_FLAG, OTA_FINISH, true, false, portMAX_DELAY);
@@ -240,4 +562,61 @@ void app_ota_start()
     }
     vEventGroupDelete(OTA_FLAG);
     periph_service_destroy(ota_service);
+    custom_ota_bin_desc_cleanup();
+}
+
+
+int bdsc_ota_start(char *url, int version)
+{
+    bdsc_stop_wakeup();
+    if (g_bdsc_engine->is_mute) {
+        audio_player_vol_set(g_bdsc_engine->cur_vol);
+    }
+    bdsc_play_hint(BDSC_HINT_OTA_START);
+    //display_service_set_pattern(disp_serv, DISPLAY_PATTERN_OTA, 0);
+
+    g_bdsc_engine->in_ota_process_flag = true;
+    app_ota_start(url);
+    g_bdsc_engine->in_ota_process_flag = false;
+    // Can not reach here if really upgrade successfully.
+    ESP_LOGW(TAG, "OTA Failed!");
+
+    // OTA error recovery
+    display_service_set_pattern(disp_serv, DISPLAY_PATTERN_WIFI_DISCONNECTED, 0);
+    if (g_bdsc_engine->is_mute) {
+        audio_player_vol_set(0);
+        display_service_set_pattern(disp_serv, DISPLAY_PATTERN_MUTE_ON, 0);
+    }
+    else {
+        bdsc_start_wakeup();
+    }
+
+    return 0;
+}
+
+static void _ota_task(void *para)
+{
+    bdsc_ota_info_t *ota_info = (bdsc_ota_info_t *) para;
+    bdsc_ota_start(ota_info->url, ota_info->ver);
+    // Can not reach here if really upgrade successfully.
+    ESP_LOGI(TAG, "_ota_task end");
+    free(ota_info->url);
+    free(ota_info);
+    vTaskDelete(NULL);
+}
+
+int bdsc_start_ota_thread(char *ota_url, int ota_version)
+{
+    ESP_LOGW(TAG, "==> start ota thread");
+    if (!ota_url || ota_version <= 0) {
+        return -1;
+    }
+    bdsc_ota_info_t *info = audio_calloc(1, sizeof(bdsc_ota_info_t));
+    info->url = audio_strdup(ota_url);
+    info->ver = ota_version;
+    if (xTaskCreate(_ota_task, "_ota_task", 3072, info, 10, NULL) != pdPASS) {
+        ESP_LOGE(TAG, "ERROR creating _ota_task task! Out of memory?");
+    }
+
+    return 0;
 }
diff --git a/examples/korvo_du1906/main/app_ota_upgrade.h b/examples/korvo_du1906/main/app_ota_upgrade.h
index 33154e08..2af90aa9 100644
--- a/examples/korvo_du1906/main/app_ota_upgrade.h
+++ b/examples/korvo_du1906/main/app_ota_upgrade.h
@@ -35,6 +35,8 @@ extern "C" {
  */
 void app_ota_start();
 
+int bdsc_ota_start(char *url, int version);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/examples/korvo_du1906/main/ota_proc_iot.c b/examples/korvo_du1906/main/ota_proc_iot.c
new file mode 100644
index 00000000..9c632b06
--- /dev/null
+++ b/examples/korvo_du1906/main/ota_proc_iot.c
@@ -0,0 +1,307 @@
+/*
+ * Copyright (c) 2020 Baidu.com, Inc. All Rights Reserved
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+#include <string.h>
+
+#include "audio_mem.h"
+#include "esp_https_ota.h"
+#include "esp_fs_ota.h"
+#include "esp_log.h"
+#include "fatfs_stream.h"
+#include "http_stream.h"
+
+#include "ota_proc_iot.h"
+#include "cJSON.h"
+
+#define READER_BUF_LEN (1024 * 2)
+
+typedef struct {
+    audio_element_handle_t r_stream;
+    const esp_partition_t *partition;
+
+    int write_offset;
+    char read_buf[READER_BUF_LEN];
+} ota_data_upgrade_ctx_t;
+
+typedef struct {
+    void *ota_handle;
+    esp_err_t (*get_img_desc)(void *handle, esp_app_desc_t *new_app_info);
+    esp_err_t (*perform)(void *handle);
+    int (*get_image_len_read)(void *handle);
+    bool (*all_read)(void *handle);
+    esp_err_t (*finish)(void *handle);
+} ota_app_upgrade_ctx_t;
+
+
+static const char *TAG = "OTA_CUSTOM";
+
+static esp_err_t validate_image_header(esp_app_desc_t *new_app_info)
+{
+    if (new_app_info == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+
+    const esp_partition_t *running = esp_ota_get_running_partition();
+    esp_app_desc_t running_app_info;
+    if (esp_ota_get_partition_description(running, &running_app_info) == ESP_OK) {
+        ESP_LOGI(TAG, "Running firmware version: %s, the incoming firmware version %s", running_app_info.version, new_app_info->version);
+    }
+
+    if (memcmp(new_app_info->version, running_app_info.version, sizeof(new_app_info->version)) == 0) {
+        ESP_LOGW(TAG, "Current running version is the same as a new. We will not continue the update.");
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+static esp_err_t ota_app_partition_prepare(void **handle, ota_node_attr_t *node)
+{
+    ota_app_upgrade_ctx_t *context = audio_calloc(1, sizeof(ota_app_upgrade_ctx_t));
+    AUDIO_NULL_CHECK(TAG, context, return ESP_FAIL);
+    *handle = context;
+
+
+    if (strstr(node->uri, "https://") || strstr(node->uri, "http://")) {
+        context->get_img_desc = esp_https_ota_get_img_desc;
+        context->perform = esp_https_ota_perform;
+        context->get_image_len_read = esp_https_ota_get_image_len_read;
+        //context->all_read = esp_https_ota_is_complete_data_received;
+        context->finish = esp_https_ota_finish;
+
+    // move to execute
+#if 0
+        esp_http_client_config_t config = {
+            .url = node->uri,
+            .cert_pem = node->cert_pem,
+            .timeout_ms = 1000,
+        };
+        esp_https_ota_config_t ota_config = {
+            .http_config = &config,
+        };
+        esp_err_t err = esp_https_ota_begin_with_pos(&ota_config, &context->ota_handle);
+        if (err != ESP_OK) {
+            ESP_LOGE(TAG, "ESP HTTPS OTA Begin failed");
+            return err;
+        }
+#endif
+    } else {
+        return ESP_FAIL;
+    }
+
+
+    return ESP_OK;
+}
+
+static esp_err_t ota_app_partition_exec_upgrade(void *handle, ota_node_attr_t *node)
+{
+    ota_app_upgrade_ctx_t *context = (ota_app_upgrade_ctx_t *)handle;
+    AUDIO_NULL_CHECK(TAG, context, return ESP_FAIL);
+    esp_err_t err = ESP_FAIL;
+
+    // skip offset bytes
+   esp_http_client_config_t config = {
+        .url = node->uri,
+        .cert_pem = node->cert_pem,
+        .timeout_ms = 10000,
+    };
+    esp_https_ota_config_t ota_config = {
+        .http_config = &config,
+    };
+    err = esp_https_ota_begin_with_pos(&ota_config, &context->ota_handle, node->cus_offset);
+    if (err != ESP_OK) {
+        ESP_LOGE(TAG, "ESP HTTPS OTA Begin failed");
+        return err;
+    }
+
+    // read desc
+    esp_app_desc_t app_desc;
+    err = context->get_img_desc(context->ota_handle, &app_desc);
+    if (err != ESP_OK) {
+        ESP_LOGE(TAG, "get_img_desc failed");
+        return false;
+    }
+    err = validate_image_header(&app_desc);
+    if (err != ESP_OK) {
+        ESP_LOGE(TAG, "image header verification failed");
+        //return false;
+    }
+
+    while (1) {
+        err = context->perform(context->ota_handle);
+        if (err != ESP_ERR_HTTPS_OTA_IN_PROGRESS && err != ESP_ERR_FS_OTA_IN_PROGRESS ) {
+            break;
+        }
+        ESP_LOGI(TAG, "Image bytes read: %d", context->get_image_len_read(context->ota_handle));
+    }
+
+    return err;
+}
+
+static esp_err_t ota_app_partition_finish(void *handle, ota_node_attr_t *node, esp_err_t result)
+{
+    ota_app_upgrade_ctx_t *context = (ota_app_upgrade_ctx_t *)handle;
+    AUDIO_NULL_CHECK(TAG, context->ota_handle, return ESP_FAIL);
+    esp_err_t err = context->finish(context->ota_handle);
+    if (err != ESP_OK) {
+        if (err == ESP_ERR_OTA_VALIDATE_FAILED) {
+            ESP_LOGE(TAG, "Image validation failed, image is corrupted");
+        }
+        ESP_LOGE(TAG, "upgrade failed %d", err);
+    }
+    audio_free(handle);
+    return err;
+}
+
+void ota_app_get_custom_proc(ota_upgrade_ops_t *ops)
+{
+    ops->prepare         = ota_app_partition_prepare;
+    ops->need_upgrade    = NULL;
+    ops->execute_upgrade = ota_app_partition_exec_upgrade;
+    ops->finished_check  = ota_app_partition_finish;
+}
+
+static esp_err_t ota_data_partition_prepare(void **handle, ota_node_attr_t *node)
+{
+    ota_data_upgrade_ctx_t *context = audio_calloc(1, sizeof(ota_data_upgrade_ctx_t));
+    AUDIO_NULL_CHECK(TAG, context, return ESP_FAIL);
+    *handle = context;
+
+    context->partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, node->label);
+    if (context->partition == NULL) {
+        ESP_LOGE(TAG, "partition [%s] not found", node->label);
+        return ESP_FAIL;
+    }
+
+    ESP_LOGI(TAG, "data upgrade uri %s", node->uri);
+    return ESP_OK;
+}
+
+static esp_err_t ota_data_partition_exec_upgrade(void *handle, ota_node_attr_t *node)
+{
+    int r_size = 0;
+    ota_data_upgrade_ctx_t *context = (ota_data_upgrade_ctx_t *)handle;
+    AUDIO_NULL_CHECK(TAG, context, return ESP_FAIL);
+
+    if (strstr(node->uri, "https://") || strstr(node->uri, "http://")) {
+        http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
+        http_cfg.type = AUDIO_STREAM_READER;
+
+        context->r_stream = http_stream_init(&http_cfg);
+    } else {
+        ESP_LOGE(TAG, "not support uri");
+        return ESP_FAIL;
+    }
+    audio_element_set_uri(context->r_stream, node->uri);
+
+    // skip offset bytes
+    audio_element_info_t info = {0};
+    audio_element_getinfo(context->r_stream, &info);
+    info.byte_pos = node->cus_offset;
+    audio_element_setinfo(context->r_stream, &info);
+
+    if (audio_element_process_init(context->r_stream) != ESP_OK) {
+        ESP_LOGE(TAG, "reader stream init failed");
+        return ESP_FAIL;
+    }
+
+    // start reading
+    while ((r_size = audio_element_input(context->r_stream, context->read_buf, READER_BUF_LEN)) > 0) {
+        ESP_LOGI(TAG, "write_offset %d, r_size %d, %x %x %x %x", context->write_offset, r_size,
+                        context->read_buf[0], context->read_buf[1],
+                        context->read_buf[2], context->read_buf[3]);
+        if (context->write_offset + r_size > node->cus_bin_len) {
+            // reach the end
+            if (esp_partition_write(context->partition, context->write_offset, context->read_buf, node->cus_bin_len - context->write_offset) == ESP_OK) {
+                context->write_offset = node->cus_bin_len;
+                return ESP_OK;
+            } else {
+                return ESP_FAIL;
+            }
+        }
+
+        if (esp_partition_write(context->partition, context->write_offset, context->read_buf, r_size) == ESP_OK) {
+            context->write_offset += r_size;
+        } else {
+            return ESP_FAIL;
+        }
+    }
+    if (r_size == AEL_IO_OK || r_size == AEL_IO_DONE) {
+        ESP_LOGI(TAG, "partition %s upgrade successes", node->label);
+        return ESP_OK;
+    } else {
+        return ESP_FAIL;
+    }
+}
+
+static esp_err_t ota_data_partition_finish(void *handle, ota_node_attr_t *node, esp_err_t result)
+{
+    ota_data_upgrade_ctx_t *context = (ota_data_upgrade_ctx_t *)handle;
+    AUDIO_NULL_CHECK(TAG, context->r_stream, return ESP_FAIL);
+    audio_element_process_deinit(context->r_stream);
+    audio_element_deinit(context->r_stream);
+
+    audio_free(handle);
+    return result;
+}
+
+void ota_data_get_custom_proc(ota_upgrade_ops_t *ops)
+{
+    ops->prepare         = ota_data_partition_prepare;
+    ops->need_upgrade    = NULL;
+    ops->execute_upgrade = ota_data_partition_exec_upgrade;
+    ops->finished_check  = ota_data_partition_finish;
+}
+
+esp_err_t ota_data_image_stream_read(void *handle, char *buf, int wanted_size)
+{
+    ota_data_upgrade_ctx_t *context = (ota_data_upgrade_ctx_t *)handle;
+
+    if (context == NULL) {
+        ESP_LOGE(TAG, "run prepare first");
+        return ESP_ERR_INVALID_STATE;
+    }
+    AUDIO_NULL_CHECK(TAG, context->r_stream, return ESP_FAIL);
+    int r_size = 0;
+    do {
+        int ret = audio_element_input(context->r_stream, buf, wanted_size - r_size);
+        if (ret > 0) {
+            r_size += ret;
+        } else {
+            break;
+        }
+    } while (r_size < wanted_size);
+
+    if (r_size == wanted_size) {
+        return ESP_OK;
+    } else {
+        return ESP_FAIL;
+    }
+}
+
+esp_err_t ota_data_partition_write(void *handle, char *buf, int size)
+{
+    ota_data_upgrade_ctx_t *context = (ota_data_upgrade_ctx_t *)handle;
+
+    if (context == NULL) {
+        ESP_LOGE(TAG, "run prepare first");
+        return ESP_ERR_INVALID_STATE;
+    }
+
+    ESP_LOGI(TAG, "write_offset %d, size %d", context->write_offset, size);
+    if (esp_partition_write(context->partition, context->write_offset, buf, size) == ESP_OK) {
+        context->write_offset += size;
+        return ESP_OK;
+    } else {
+        return ESP_FAIL;
+    }
+}
diff --git a/examples/korvo_du1906/main/ota_proc_iot.h b/examples/korvo_du1906/main/ota_proc_iot.h
new file mode 100644
index 00000000..d4a6c1e9
--- /dev/null
+++ b/examples/korvo_du1906/main/ota_proc_iot.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2020 Baidu.com, Inc. All Rights Reserved
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+#ifndef __OTA_PROC_IOT_H__
+#define __OTA_PROC_IOT_H__
+
+#include "esp_ota_ops.h"
+#include "esp_partition.h"
+
+#include "audio_element.h"
+#include "ota_service.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+  * @brief     get the custom process of `app partition` upgrade
+  *
+  * @param[in]  handle          pointer to `ota_upgrade_ops_t` structure
+  *
+  * @return
+  *    - void
+  */
+void ota_app_get_custom_proc(ota_upgrade_ops_t *ops);
+
+/**
+  * @brief     get the custom process of `data partition` upgrade
+  *
+  * @param[in]  handle          pointer to `ota_upgrade_ops_t` structure
+  *
+  * @return
+  *    - void
+  */
+void ota_data_get_custom_proc(ota_upgrade_ops_t *ops);
+
+/**
+  * @brief     read from the stream of upgrading
+  *
+  * @param[in]  handle          pointer to upgrade handle
+  * @param[in]  buf             pointer to receive buffer
+  * @param[in]  wanted_size     bytes to read
+  *
+  * @return
+  *    - ESP_OK:  Success
+  *    - Others:  Failed
+  */
+esp_err_t ota_data_image_stream_read(void *handle, char *buf, int wanted_size);
+
+/**
+  * @brief     write to the data partition under upgrading
+  *
+  * @param[in]  handle          pointer to upgrade handle
+  * @param[in]  buf             pointer to data buffer
+  * @param[in]  size            bytes to write
+  *
+  * @return
+  *    - ESP_OK:  Success
+  *    - Others:  Failed
+  */
+esp_err_t ota_data_partition_write(void *handle, char *buf, int size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__OTA_PROC_DEFAULT__*/
\ No newline at end of file
-- 
2.17.1

